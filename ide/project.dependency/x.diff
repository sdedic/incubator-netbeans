diff --git a/ide/project.dependency/src/org/netbeans/modules/project/dependency/ArtifactSpec.java b/ide/project.dependency/src/org/netbeans/modules/project/dependency/ArtifactSpec.java
index c6989c56a155..0bdc541f5a94 100644
--- a/ide/project.dependency/src/org/netbeans/modules/project/dependency/ArtifactSpec.java
+++ b/ide/project.dependency/src/org/netbeans/modules/project/dependency/ArtifactSpec.java
@@ -162,6 +162,7 @@ public final class ArtifactSpec<T> {
         hash = 79 * hash + Objects.hashCode(this.artifactId);
         hash = 79 * hash + Objects.hashCode(this.versionSpec);
         hash = 79 * hash + Objects.hashCode(this.classifier);
+        hash = 79 * hash + Objects.hashCode(this.location);
         return hash;
     }
 
@@ -192,6 +193,9 @@ public final class ArtifactSpec<T> {
         if (!Objects.equals(this.classifier, other.classifier)) {
             return false;
         }
+        if (!Objects.equals(this.location, other.location)) {
+            return false;
+        }
         return this.kind == other.kind;
     }
     
@@ -222,7 +226,7 @@ public final class ArtifactSpec<T> {
     }
     
     public static <V> ArtifactSpec<V> createVersionSpec(
-            String groupId, @NonNull String artifactId, 
+            @NullAllowed String groupId, @NonNull String artifactId, 
             @NullAllowed String type, @NullAllowed String classifier, 
             @NonNull String versionSpec, boolean optional, @NullAllowed FileObject localFile, @NonNull V data) {
         URL u = localFile == null ? null : URLMapper.findURL(localFile, URLMapper.EXTERNAL);
diff --git a/ide/project.dependency/src/org/netbeans/modules/project/dependency/ProjectArtifactsQuery.java b/ide/project.dependency/src/org/netbeans/modules/project/dependency/ProjectArtifactsQuery.java
index 0adb82e5c5c0..f92840bfdee0 100644
--- a/ide/project.dependency/src/org/netbeans/modules/project/dependency/ProjectArtifactsQuery.java
+++ b/ide/project.dependency/src/org/netbeans/modules/project/dependency/ProjectArtifactsQuery.java
@@ -22,6 +22,9 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.SortedMap;
+import java.util.TreeMap;
+import java.util.stream.Collectors;
 import javax.swing.event.ChangeEvent;
 import javax.swing.event.ChangeListener;
 import org.netbeans.api.annotations.common.CheckForNull;
@@ -33,27 +36,80 @@ import org.netbeans.modules.project.dependency.spi.ProjectArtifactsImplementatio
 import org.openide.util.*;
 
 /**
- *
+ * This project query provides access to artifacts produced or managed by a project. An artifact
+ * is essentially a file (may extend to a collection of files in the future) that is a product of a project build,
+ * or generally of a project or build system action. A project can have multiple artifacts produced by a build,
+ * or can have multiple sets of artifacts produced by specific project actions. 
+ * <p>
+ * By default the query will return artifacts produced by project's compilation (incl. packaging, in maven terminology) - 
+ * but the exact meaning depends on a build system used, and the project's settings and the active configuration.
+ * 
  * @author sdedic
  */
 public final class ProjectArtifactsQuery {
     
+    /**
+     * Computes artifacts produced by a project. The returned Result can enumerate artifacts
+     * from the project, along with their location(s) either actual or supposed. The Result can
+     * be listened of changes that may change the artifacts reported.
+     * 
+     * @param project the project to be queried
+     * @param filter artifact filter
+     * @return list of artifacts that can be listened on.
+     */
     public static ArtifactsResult findArtifacts(Project project, Filter filter) {
         Parameters.notNull("project", project);
         Parameters.notNull("filter", filter);
-        List<ProjectArtifactsImplementation.Result> delegates = new ArrayList<>();
-        for (ProjectArtifactsImplementation impl : project.getLookup().lookupAll(ProjectArtifactsImplementation.class)) {
-            ProjectArtifactsImplementation.Result r = impl.findArtifacts(filter);
+        
+        List<ProjectArtifactsImplementation> impls = new ArrayList<>(project.getLookup().lookupAll(ProjectArtifactsImplementation.class));
+        SortedMap<Integer, List<E<?>>> buckets = new TreeMap<>();
+        for (ProjectArtifactsImplementation impl : impls) {
+            Object r = impl.evaluate(filter);
             if (r != null) {
-                delegates.add(r);
+                buckets.computeIfAbsent(impl.getOrder(), i -> new ArrayList<>()).add(new E(r, impl));
             }
         }
-        
+        List<E<?>> delegates;
+        if (buckets.size() == 1) {
+            delegates = buckets.values().iterator().next();
+        } else {
+            delegates = buckets.values().stream().flatMap(l -> l.stream()).collect(Collectors.toList());
+        }
         return new ArtifactsResult(delegates);
     }
     
+    private static final class E<T> {
+        final T data;
+        final ProjectArtifactsImplementation<T> impl;
+
+        public E(T data, ProjectArtifactsImplementation<T> impl) {
+            this.data = data;
+            this.impl = impl;
+        }
+        
+        public Project findProject() {
+            return impl.findProject(data);
+        }
+
+        public List<ArtifactSpec> findArtifacts() {
+            return impl.findArtifacts(data);
+        }
+
+        public Collection<ArtifactSpec> findExcludedArtifacts() {
+            return impl.findExcludedArtifacts(data);
+        }
+
+        public void handleChangeListener(ChangeListener l, boolean add) {
+            impl.handleChangeListener(data, l, add);
+        }
+
+        public boolean computeSupportsChanges() {
+            return impl.computeSupportsChanges(data);
+        }
+    }
+    
     public static final class ArtifactsResult {
-        private final List<ProjectArtifactsImplementation.Result> delegates;
+        private final List<E<?>> delegates;
 
         // @GuardedBy(this)
         private final List<ChangeListener> listeners = new ArrayList<>();
@@ -64,10 +120,15 @@ public final class ProjectArtifactsQuery {
         // @GuardedBy(this)
         private Boolean supportsChanges;
 
-        ArtifactsResult(List<ProjectArtifactsImplementation.Result> delegates) {
+        ArtifactsResult(List<E<?>> delegates) {
             this.delegates = delegates;
         }
         
+        /**
+         * Returns project artifacts. The result may become invalida after the result fires
+         * an event to its {@link #addChangeListener(javax.swing.event.ChangeListener) ChangeListeners}.
+         * @return artifacts produced by the project. 
+         */
         public List<ArtifactSpec> getArtifacts() {
             synchronized (this) {
                 if (artifacts != null) {
@@ -80,16 +141,16 @@ public final class ProjectArtifactsQuery {
         List<ArtifactSpec> updateResults() {
             boolean changes = false;
             Collection<ArtifactSpec> specs = new LinkedHashSet<>();
-            for (ProjectArtifactsImplementation.Result d : delegates) {
-                Collection<ArtifactSpec> ex = d.getExcludedArtifacts();
+            for (E<?> e : delegates) {
+                Collection<ArtifactSpec> ex = e.findExcludedArtifacts();
                 if (ex != null) {
                     specs.removeAll(ex);
                 }
-                Collection<ArtifactSpec> add = d.getArtifacts();
+                Collection<ArtifactSpec> add = e.findArtifacts();
                 if (add != null) {
                     specs.addAll(add);
                 }
-                changes |= d.supportsChanges();
+                changes |= e.computeSupportsChanges();
             }
             List<ArtifactSpec> copy = new ArrayList<>(specs);
             ChangeListener[] ll;
@@ -115,21 +176,31 @@ public final class ProjectArtifactsQuery {
             return copy;
         }
         
+        /**
+         * Adds a listener that will be informed of changes. An event will fire if
+         * the project changes in a way that might affect the reported artifacts.
+         * 
+         * @param l the listener
+         */
         public void addChangeListener(ChangeListener l) {
             synchronized (this) {
-                if (supportsChanges == Boolean.FALSE) {
+                if (Boolean.FALSE.equals(supportsChanges)) {
                     return;
                 }
                 if (delListener == null) {
                     delListener = WeakListeners.change((e) -> updateResults(), null);
-                    for (ProjectArtifactsImplementation.Result d : delegates) {
-                        d.addChangeListener(delListener);
+                    for (E d : delegates) {
+                        d.handleChangeListener(delListener, true);
                     }
                 }
                 listeners.add(l);
             }
         }
         
+        /**
+         * Removes a previously registered Listener.
+         * @param l the listener to unregister
+         */
         public void removeChangeListener(ChangeListener l) {
             synchronized (this) {
                 listeners.remove(l);
diff --git a/ide/project.dependency/src/org/netbeans/modules/project/dependency/spi/ProjectArtifactsImplementation.java b/ide/project.dependency/src/org/netbeans/modules/project/dependency/spi/ProjectArtifactsImplementation.java
index 3c4fcee7e04e..198350a10b39 100644
--- a/ide/project.dependency/src/org/netbeans/modules/project/dependency/spi/ProjectArtifactsImplementation.java
+++ b/ide/project.dependency/src/org/netbeans/modules/project/dependency/spi/ProjectArtifactsImplementation.java
@@ -29,38 +29,42 @@ import org.netbeans.modules.project.dependency.ProjectArtifactsQuery;
  *
  * @author sdedic
  */
-public interface ProjectArtifactsImplementation {
+public interface ProjectArtifactsImplementation<Result> {
     /**
-     * Finds project artifact(s) that match the query. 
+     * Finds project artifact(s) that match the query. The implementation should
+     * compute data and store it into implementation-defined Result data structure,
+     * which will be used during subsequent calls.
+     * 
      * @param query the query to answer
-     * @param previous result of previous buildsteps
-     * @param all
-     * @return 
+     * @return result structure.
      */
-    public Result findArtifacts(ProjectArtifactsQuery.Filter query);
-    
-    public interface Result {
-        public Project getProject();
-        
-        /**
-         * @return Reports project artifacts.
-         */
-        public List<ArtifactSpec> getArtifacts();
+    public Result evaluate(ProjectArtifactsQuery.Filter query);
 
-        /**
-         * If not null, specifies artifacts to be excluded from the final result. For example
-         * a transformation plugin may rename the original artifact so that the original place
-         * is empty.
-         * @return excluded artifacts, or {@code null}.
-         */
-        public Collection<ArtifactSpec> getExcludedArtifacts();
-        
-        public default void addChangeListener(ChangeListener l) {}
-        
-        public default void removeChangeListener(ChangeListener l) {}
-        
-        public default boolean supportsChanges() {
-            return false;
-        }
+    /**
+     * Returns evaluation order of this Implementation. If the Implementation needs to post-process
+     * 
+     * @return 
+     */
+    public default int getOrder() {
+        return 10000;
     }
+    
+    public Project findProject(Result r);
+    
+    /**
+     * @return Reports project artifacts.
+     */
+    public List<ArtifactSpec> findArtifacts(Result r);
+    
+    /**
+     * If not null, specifies artifacts to be excluded from the final result. For example
+     * a transformation plugin may rename the original artifact so that the original place
+     * is empty.
+     * @return excluded artifacts, or {@code null}.
+     */
+    public Collection<ArtifactSpec> findExcludedArtifacts(Result r);
+    
+    public void handleChangeListener(Result r, ChangeListener l, boolean add);
+    
+    public boolean computeSupportsChanges(Result r);
 }
