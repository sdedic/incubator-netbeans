/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.netbeans.modules.cloud.oracle.adm;

import com.oracle.bmc.adm.ApplicationDependencyManagementClient;
import com.oracle.bmc.adm.model.ApplicationDependency;
import com.oracle.bmc.adm.model.ApplicationDependencyVulnerabilitySummary;
import com.oracle.bmc.adm.model.CreateVulnerabilityAuditDetails;
import com.oracle.bmc.adm.model.Vulnerability;
import com.oracle.bmc.adm.model.VulnerabilityAudit;
import com.oracle.bmc.adm.model.VulnerabilityAuditConfiguration;
import com.oracle.bmc.adm.model.VulnerabilityAuditSummary;
import com.oracle.bmc.adm.requests.CreateVulnerabilityAuditRequest;
import com.oracle.bmc.adm.requests.ListApplicationDependencyVulnerabilitiesRequest;
import com.oracle.bmc.adm.requests.ListVulnerabilityAuditsRequest;
import com.oracle.bmc.adm.responses.CreateVulnerabilityAuditResponse;
import com.oracle.bmc.adm.responses.ListApplicationDependencyVulnerabilitiesResponse;
import com.oracle.bmc.adm.responses.ListVulnerabilityAuditsResponse;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.netbeans.api.editor.mimelookup.MimeRegistration;
import org.netbeans.api.lsp.CodeAction;
import org.netbeans.api.lsp.Command;
import org.netbeans.api.lsp.Diagnostic;
import org.netbeans.api.progress.ProgressHandle;
import org.netbeans.api.project.Project;
import org.netbeans.api.project.ProjectUtils;
import org.netbeans.modules.cloud.common.explorer.CloudItem;
import org.netbeans.modules.cloud.common.project.CloudResourcesStorage;
import org.netbeans.modules.cloud.oracle.OCIManager;
import org.netbeans.modules.project.dependency.ArtifactSpec;
import org.netbeans.modules.project.dependency.Dependency;
import org.netbeans.modules.project.dependency.DependencyResult;
import org.netbeans.modules.project.dependency.ProjectDependencies;
import org.netbeans.modules.project.dependency.Scopes;
import org.netbeans.modules.project.dependency.SourceLocation;
import org.netbeans.spi.lsp.ErrorProvider;
import org.openide.DialogDisplayer;
import org.openide.NotifyDescriptor;
import org.openide.filesystems.FileObject;
import org.openide.util.Exceptions;
import org.openide.util.Lookup;
import org.openide.util.NbBundle;

/**
 *
 * @author Petr Pisl
 */

@NbBundle.Messages({
    "MSG_Audit_Pass=Vulnerability audit for project {0} is done.\nNo vulnerability was found.",
    "MSG_Audit_Failed_One=Vulnerability audit for project {0} is done.\nOne vulnerability was found.\nThe vulnerability is listed in Problems window.",
    "MSG_Audit_Failed_More=Vulnerability audit for project {0} is done.\n{1} vulnerabilities were found.\nThe vulnerabilities are listed in Problems window.",
    "MSG_CreatingAuditFailed=Creating Vulnerablity audit for project {0} failed.",
    "MSG_ListingAuditFailed=Obtaining newly created vulnerablity audit for project {0} failed.",
    "MSG_ListingVulnerabilitiesFailed=Obtaining vulnerabilities for newly created audit failed.",
    "MSG_AuditIsRunning=Audit of %s project is running ...",
    "MSG_NotAvailable=Not available",
    "MSG_Diagnostic=Vulnerability\n"
            + "  Cvss V2 Score: %s\n"
            + "  Cvss V3 Score: %s\n"
            + "  Caused by dependence: %s"
})
 
@MimeRegistration(mimeType = "text/x-maven-pom+xml", service = ErrorProvider.class)
public class VulnerabilityWorker implements ErrorProvider{

    private static final String GOV_DETAIL_URL = "https://nvd.nist.gov/vuln/detail/";
    
    static class CacheItem {
        private DependencyResult dependencyResult;
        private VulnerabilityAuditSummary audit;
        private List<ApplicationDependencyVulnerabilitySummary> vulnerabilities;
        private Map<String, Dependency> dependencyMap;
        private HashMap<FileObject, List<Diagnostic>> diagnostics;

        public CacheItem(DependencyResult dependency, VulnerabilityAuditSummary audit, List<ApplicationDependencyVulnerabilitySummary> vulnerabilities) {
            this.dependencyResult = dependency;
            this.audit = audit;
            this.vulnerabilities = vulnerabilities;
        }

        public DependencyResult getDependency() {
            return dependencyResult;
        }

        public VulnerabilityAuditSummary getAudit() {
            return audit;
        }

        public List<ApplicationDependencyVulnerabilitySummary> getVulnerabilities() {
            return vulnerabilities;
        }

        public Map<String, Dependency> getDependencyMap() {
            if (dependencyMap == null) {
                dependencyMap = new HashMap();
                buildDependecyMap(dependencyResult.getRoot(), dependencyMap);
            }
            return dependencyMap;
        }
        
        private void buildDependecyMap(Dependency dependency, Map<String, Dependency> result) {
            String gav = createGAV(dependency.getArtifact());
            result.put(gav, dependency);
            dependency.getChildren().forEach((childDependency) -> {
                buildDependecyMap(childDependency, result);
            });
        }
        
        public Set<FileObject> getProblematicFiles() {
            if (audit.getIsSuccess()) {
                return Collections.EMPTY_SET;
            }
            Set<FileObject> result = new HashSet();
            for (ApplicationDependencyVulnerabilitySummary v: vulnerabilities){
                List<Vulnerability> vulnerabilities = v.getVulnerabilities();
                if (!vulnerabilities.isEmpty()) {
                    Dependency dep = getDependencyMap().get(v.getGav());
                    if (dep != null) {
                        try {
                            SourceLocation declarationRange = this.dependencyResult.getDeclarationRange(dep, null);
                            if(declarationRange != null) {
                                result.add(declarationRange.getFile());
                            }
                        } catch (IOException ex) {
                            Exceptions.printStackTrace(ex);
                        }
                    }
                }
            }
            return result;
        }
        
        public List<Diagnostic> getDiagnosticsForFile(FileObject file) {
            if (diagnostics == null) {
                diagnostics = new HashMap();
            }
            
            if (/*!diagnostics.containsKey(file) &&*/ vulnerabilities != null) {
                List<Diagnostic> result = new ArrayList();
                for (ApplicationDependencyVulnerabilitySummary v: vulnerabilities){
                    List<Vulnerability> vulnerabilities = v.getVulnerabilities();
                    if (!vulnerabilities.isEmpty()) {
                        Dependency dependency = getDependencyMap().get(v.getGav());
                        if (dependency != null) {
                            try {
                                SourceLocation declarationRange = this.dependencyResult.getDeclarationRange(dependency, null);
                                if (declarationRange != null && declarationRange.hasPosition() && declarationRange.getFile().equals(file)) {
                                    for(Vulnerability vulnerability: vulnerabilities) {
                                        String message = String.format(Bundle.MSG_Diagnostic(), 
                                                formatCvssScore(vulnerability.getCvssV2Score()), 
                                                formatCvssScore(vulnerability.getCvssV3Score()), 
                                                createGAV(dependency.getArtifact()));
                                        Diagnostic.Builder builder = Diagnostic.Builder.create(() -> declarationRange.getStartOffset(), () -> declarationRange.getEndOffset(), message);
                                        builder.setSeverity(Diagnostic.Severity.Warning).setCode(vulnerability.getId());
                                        builder.setCodeDescription(new URL(GOV_DETAIL_URL + vulnerability.getId()));
                                        result.add(builder.build());
                                    }
                                }
                            } catch (IOException ex) {
                                Exceptions.printStackTrace(ex);
                            }

                        }
                    }
                }
                diagnostics.put(file, result.isEmpty() ? Collections.EMPTY_LIST : result);
            }
            return diagnostics.get(file);
        }
        
        private String formatCvssScore(Float value) {
            if (value != null) {
                return String.format("%.2f", value);
            }
            return Bundle.MSG_NotAvailable();
        }
    }
    
    private static HashMap<Project, CacheItem> cache = new HashMap();
    private static VulnerabilityWorker instance;

    private VulnerabilityWorker() {

    }

    public static VulnerabilityWorker getInstance() {
        if (instance == null) {
            instance = new VulnerabilityWorker();

        }
        return instance;
    }

    public void findVulnerability(Project project) {
        final String projectDisplayName = ProjectUtils.getInformation(project).getDisplayName();
        KnowledgeBaseItem kbItem = getKnowledgeBaseForProject(project);
        if (kbItem == null) {
            System.out.println("!!!!! no assigned KB for Project. ");
            return;
        }
        ProgressHandle progressHandle = ProgressHandle.createHandle(String.format(Bundle.MSG_AuditIsRunning(), projectDisplayName));
        progressHandle.start();
        
        // remove from the cache old values
        cache.remove(project);
        
        DependencyResult dr = ProjectDependencies.findDependencies(project, ProjectDependencies.newQuery(Scopes.RUNTIME));
        List<ApplicationDependency> result = new ArrayList();
        convert(dr.getRoot(), 0, result);

//        System.out.println("--- Dependency table ---");
//        for (ApplicationDependency dep : result) {
//            System.out.print("" + dep.getNodeId() + "," + dep.getGav());
//            for (String text : dep.getApplicationDependencyNodeIds()) {
//                System.out.print("," + text);
//            }
//            System.out.println();
//            
//        }
//        System.out.println("--- End of Dependency table ---");
        String compartmentId = kbItem.compartmentId;
        String knowledgeBaseId = kbItem.getKey().getValue();
        
        try (ApplicationDependencyManagementClient admClient
                = new ApplicationDependencyManagementClient(OCIManager.getDefault().getConfigProvider())) {
            final VulnerabilityAuditConfiguration auditConfiguration = VulnerabilityAuditConfiguration
                    .builder()
                    .maxPermissibleCvssV2Score(1f)
                    .maxPermissibleCvssV3Score(1f)
                    .exclusions(Collections.unmodifiableList(Collections.EMPTY_LIST))
                    .build();
            final CreateVulnerabilityAuditDetails auditDetails = CreateVulnerabilityAuditDetails
                    .builder()
                    .compartmentId(compartmentId)
                    .knowledgeBaseId(knowledgeBaseId)
                    .displayName(projectDisplayName)
                    .buildType(VulnerabilityAudit.BuildType.Maven)
                    .configuration(auditConfiguration)
                    .applicationDependencies(result)
                    .build();
            CreateVulnerabilityAuditResponse response = admClient.createVulnerabilityAudit(CreateVulnerabilityAuditRequest
                    .builder()
                    .createVulnerabilityAuditDetails(auditDetails)
                    .build());
            if (response.get__httpStatusCode__() != 201 && response.get__httpStatusCode__() != 200) {
                ErrorUtils.processError(response, Bundle.MSG_CreatingAuditFailed(projectDisplayName));
            } else {
                // audit is ok
                final CacheItem cacheItem = waitToAuditFinish(admClient, dr, response.getVulnerabilityAudit(), projectDisplayName);
                if (cacheItem != null) {
                    cache.put(project, cacheItem);
                    
                    Set<FileObject> problematicFiles = new HashSet();
                    problematicFiles.addAll(cacheItem.getProblematicFiles());
                    
                    String message;
                    if (cacheItem.audit.getIsSuccess()) {
                        message = Bundle.MSG_Audit_Pass(projectDisplayName);
                        FileObject projectDirectory = project.getProjectDirectory();
                        // TODO this is really ugly
                        FileObject pomXml = projectDirectory.getFileObject("pom.xml");
                        problematicFiles.add(pomXml);
                    } else if(cacheItem.audit.getVulnerableArtifactsCount() == 1) {
                        message = Bundle.MSG_Audit_Failed_One(projectDisplayName);
                    } else {
                        message = Bundle.MSG_Audit_Failed_More(projectDisplayName, cacheItem.audit.getVulnerableArtifactsCount());
                    }
                    DialogDisplayer.getDefault().notifyLater(
                                    new NotifyDescriptor.Message(message));
                    Diagnostic.ReporterControl reporter = Diagnostic.findReporterControl(Lookup.getDefault(), project.getProjectDirectory());
                    reporter.diagnosticChanged(problematicFiles, null);
                    kbItem.refresh();
                }
            }
        } finally {
            progressHandle.finish();
        }
    }

    
    public static KnowledgeBaseItem getKnowledgeBaseForProject(Project project) {
        CloudResourcesStorage storage = project.getLookup().lookup(CloudResourcesStorage.class);
        KnowledgeBaseItem kbItem = null;
        if (storage != null) {
            for (CloudItem item : storage.items()) {
                if ("Oracle/KnowledgeBase".equals(item.getKey().getPath())) {
                   kbItem = (KnowledgeBaseItem) item;
                   break;
                }
            }
        }
        return kbItem;
    }
    
    private int convert(Dependency dependency, int counter, List<ApplicationDependency> result) {
        ApplicationDependency.Builder builder = ApplicationDependency.builder();
        builder.gav(createGAV(dependency.getArtifact()));
        List<String> childrenNodeIds = new ArrayList(dependency.getChildren().size());
        for (Dependency childDependency : dependency.getChildren()) {
            counter = convert(childDependency, counter, result);
            childrenNodeIds.add(Integer.toString(counter));
        }
        builder.applicationDependencyNodeIds(childrenNodeIds);
        builder.nodeId(Integer.toString(++counter));
        result.add(builder.build());
        return counter;
    }

    private static String createGAV(ArtifactSpec artifact) {
        StringBuffer sb = new StringBuffer();
        sb.append(artifact.getGroupId()).append(':');
        sb.append(artifact.getArtifactId()).append(':');
        sb.append(artifact.getVersionSpec());
        return sb.toString();
    }

    private CacheItem waitToAuditFinish(ApplicationDependencyManagementClient client, DependencyResult dr, VulnerabilityAudit audit, String projectName) {                
        ListVulnerabilityAuditsRequest request = ListVulnerabilityAuditsRequest.builder()
                .knowledgeBaseId(audit.getKnowledgeBaseId()).id(audit.getId()).build();
        VulnerabilityAuditSummary auditSummary;
        boolean first = true;
        do {
            if (first) {
                first = false;
            } else {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException ex) {
                    Exceptions.printStackTrace(ex);
                }
            }
            ListVulnerabilityAuditsResponse response = client.listVulnerabilityAudits(request);
            if (response.get__httpStatusCode__() != 200) {
                ErrorUtils.processError(response, Bundle.MSG_ListingAuditFailed(projectName));
                return null;
            }
            List<VulnerabilityAuditSummary> items = response.getVulnerabilityAuditCollection().getItems();
            auditSummary = items.get(0);
        } while (auditSummary.getLifecycleState() == VulnerabilityAudit.LifecycleState.Creating);

        if (auditSummary.getVulnerableArtifactsCount() > 0) {
            ListApplicationDependencyVulnerabilitiesRequest advRequest = ListApplicationDependencyVulnerabilitiesRequest.builder().vulnerabilityAuditId(audit.getId()).build();
            ListApplicationDependencyVulnerabilitiesResponse vulners = client.listApplicationDependencyVulnerabilities(advRequest);
            if (vulners.get__httpStatusCode__() == 200) {
                List<ApplicationDependencyVulnerabilitySummary> items = vulners.getApplicationDependencyVulnerabilityCollection().getItems();
                return new CacheItem(dr, auditSummary, items);
            } else {
                ErrorUtils.processError(vulners, Bundle.MSG_ListingVulnerabilitiesFailed());
            }
        } 
        return new CacheItem(dr, auditSummary, null);
    }
    
    @Override
    public List<? extends Diagnostic> computeErrors(Context context) {
        if (!cache.isEmpty()) {
            List<Diagnostic> result = new ArrayList();
            for (CacheItem cacheItem : cache.values()) {
                List<Diagnostic> diagnostics = cacheItem.getDiagnosticsForFile(context.file());
                if (diagnostics != null) {
                    result.addAll(cacheItem.getDiagnosticsForFile(context.file()));
                }
            }
            return result;
        }
        return Collections.EMPTY_LIST;
    }
    
    
}
